---
title: 图解mysql中的binlog、redo log和undo log
date: 2023-01-04 15:07:14
categories:
- 数据库
tags:
---
从一条 SQL 的执行讲起：
![](01.gif)


就算是一条简简单单的更新语句，也要经过 MySQL 的 Server 层和存储引擎层
InnoDB 存储引擎
从上面的 SQL 执行图可以看出，数据的落盘和日志的记录都与 InnoDB 存储引擎有着密切的关系。

那存储引擎到底是什么呢？

“引擎”一词来源于发动机，它是发动机中的核心部分，后面引申到软件工程领域，代表的是软件或者系统的核心。

在 MySQL 中，核心的存储数据的模块被称为存储引擎。

在 MySQL 中，存储引擎是插件式的，用户可以根据不同的需求去使用不同的存储引擎。

把存储引擎插件化有什么好处呢？

我认为有以下三点好处：

将 Server 层与存储引擎解耦，留下扩展点，方便后续的迭代与发展
让用户有更多的选择，根据不同的需求选择合适的存储引擎
让 MySQL 便于结合更多优秀的存储引擎
我这三点推断并不是空穴来风，不信我和你一起回顾一下 MySQL 的发展史:

MySQL 最初搭载的存储引擎是自研的只支持简单的查询的 MyISAM 的前身 ISAM

后来与 Sleepycat 合作研发了 Berkeley DB 引擎，支持了事务

但尽管如此，MySQL 这些自研的存储引擎在很大一部分场景都干不过 InnobaseOy 公司的 InnoDB 存储引擎。

怎么办呢？打不过就加入呗。

我有我的 SQL 技术，你有你的存储技术，我们何不合作共同发展呢？
![](02.jpg)

于是在 2001 年，MySQL 所在的公司和 InnobaseOy 公司合作，决定在 MySQL 中集成 InnoDB 存储引擎。

因为 MySQL 存储引擎的插件化设计，两个公司合作的非常轻松与愉快，很快就发布了 MySQL4.0 正式支持功能强大的 InnoDB。

虽说不能把 MySQL 的成功全部归功于存储引擎的插件化设计，但不得不说，存储引擎插件化大大加速了 MySQL 的发展。

从发展史也可以了解到，InnoDB 一开始并不是 MySQL 的一部分，只是后来被集成到了 MySQL 里面。这一点很关键，后面还会再次提到。

Buffer Pool
在 InnoDB 里，有一块非常重要的结构——Buffer Pool。

Buffer Pool 是个什么东西呢？

Buffer Pool 就是一个缓存磁盘数据的内存空间，将磁盘 IO 操作转换成内存操作，提高执行效率。

讲白了，就是将磁盘上的数据放到内存中来，有什么操作直接在内存中执行，不需要每次都去磁盘上取数据，然后操作完后再将数据刷到磁盘。

通过一个例子说明，假设要执行 3 个更新 SQL，将 age=1 这个数据依次更新成 2、3、4。

如果没有 Buffer Pool，那执行就是这样的：
![](03.gif)

每次更新都需要从磁盘拿数据，修改完了需要刷到磁盘，3 次更新一共有 6 次磁盘 IO。

而有了 Buffer Pool，执行就成了这样：
![](04.gif)

一共执行了 1 次 IO 操作，20 次内存操作。

上面这个例子，执行 10 条 SQL，有了 Buffer Pool 之后，节省了 19 次的磁盘 IO。

当然，Buffer Pool 真正的运转流程没有这么简单，具体实现细节和优化技巧还有很多，由于篇幅有限，本文不做详细描述。

我们需要明白的是，Buffer Pool 就是将磁盘 IO 转换成了内存 IO，提高了执行效率。

Buffer Pool 是提高了效率没错，但是出现了一个问题，Buffer Pool 存在于内存中，而只要一断电或者 MySQL 所在服务器挂掉，内存里面的数据就会全部丢失。

如果断电的时候 Buffer Pool 的数据还没来得及刷到磁盘，那么这些数据就丢失了。
![](05.gif)

试想一下，如果这些丢失的数据里面有你给女神买包的订单信息，你能不能接受？

反正我是不能接受。

那 InnoDB 是如何做到数据不会丢失的呢？

今天的第一个日志——redo log 登场了。

redo log
从名字上面来看，redo 是重做的意思，redo log 就是重做日志的意思。

具体来说，就是在修改之后，先将修改后的值记录到磁盘上的 redo log 中，就算突然断电了，Buffer Pool 中的数据全部丢失了，来电的时候也可以根据 redo log 恢复 Buffer Pool，这样既利用到了 Buffer Pool 的内存高效性，也保证了数据不会丢失。
![](06.gif)

那么问题来了，redo log 文件也在磁盘上，数据文件也在磁盘上，都是磁盘操作，何必多此一举？为什么不直接将修改的数据写到数据文件里面去呢？
![](07.jpg)

一句话回答就是：redo log 是磁盘顺序写，数据刷盘是磁盘随机写。磁盘的顺序写比随机写高效的多。

所以啊，这一波先记 redo log 还是有用的。

在关系数据库中，这种先预写日志后面再将数据刷盘的机制，有一个高大上的专业名词——WAL（Write-ahead logging），翻译成中文就是预写式日志。

面试的时候，你要是满嘴这些高大上的名词，面试官很难不抬头打量你呀。
![](08.jpg)

言归正传，redo log 并不是直接记到磁盘的 redo log 文件里面，而是先记录在一个叫 redo log buffer 的地方，redo log buffer 和 Buffer Pool 类似，起到了一个缓冲的作用。

参数 innodb_flush_log_at_trx_commit 用来控制 redo log 的刷盘策略，设置不同的值同步 redo log 的策略也是不一样的。

这个参数 有 3 个值可以设置：

innodb_flush_log_at_trx_commit = 0：延迟写，延迟刷
这种策略在事务提交时不会向磁盘中同步 redo log，这个同步的工作由后台线程定时去做。

这种策略效率是最高的，但是如果事务提交后服务器挂了，后台线程又没有及时将 redo log 刷新到磁盘，那么该事务对页面的修改会丢失。
![](09.gif)

innodb_flush_log_at_trx_commit = 1：实时写，实时刷
这种策略会在每次事务提交之前，将对应的 redo log 刷到磁盘中去，理论上只要磁盘不出问题，数据就不会丢失。
![](10.gif)

innodb_flush_log_at_trx_commit = 2：实时写，延迟刷
这种策略在事务提交之前会把 redo log 写到 os cache 中，但并不会实时地将日志刷新到磁盘。

这种情况下如果 MySQL 进程挂了，操作系统没挂的话，操作系统还是会将 os cache 刷到磁盘，数据不会丢失。
![](11.gif)

但如果 MySQL 所在的服务器挂掉了，也就是操作系统也挂了，那么 os cache 也会被清空，数据就丢失了。
![](12.gif)

信我，别整那么花里胡哨的，参数 innodb_flush_log_at_trx_commit 你就老老实实用默认的 1 就行了，不丢数据不背锅，非常的香。

undo log
我们都知道，InnoDB 是支持事务的，而事务是可以回滚的。

假如一个事务将 age=1 修改成了 age=2，在事务还没有提交的时候，后台线程已经将 age=2 刷入了磁盘。这个时候，不管是内存还是磁盘上，age 都变成了 2，如果事务要回滚，找不到修改之前的 age=1，无法回滚了。
![](13.gif)

那怎么办呢？

很简单，把修改之前的 age=1 存起来不就行了吗，回滚的时候根据存起来的 age=1 回滚就行了。

这个存修改之前的 age=1 的过程，就叫做记录 undo log。

undo 翻译成中文是撤销、回滚的意思。事实上，undo log 最大的作用就是回滚。
![](14.gif)

undo log 默认存在全局表空间里面，你可以简单的理解成 undo log 也是存在一个 MySQL 的表里面，插入一条 undo log 和插入一条普通数据类似。所以，写入 undo log 的过程中同样也是要写入 redo log 的。

binlog
undo log 记录的是修改之前的值，提供回滚的能力。

redo log 记录的是修改之后的值，提供了崩溃恢复的能力。

那 binlog 是干什么的呢？

binlog 记录的是修改之后的值，用于归档。

和 redo log 日志类似，binlog 也有着自己的刷盘策略，通过 sync_binlog 参数控制：

sync_binlog = 0 ：每次提交事务前将 binlog 写入 os cache，由操作系统控制什么时候刷到磁盘
sync_binlog = 1 ：采用同步写磁盘的方式来写 binlog，不使用 os cache 来写 binlog
sync_binlog = N ：当每进行 n 次事务提交之后，调用一次 fsync 将 os cache 中的 binlog 强制刷到磁盘
这个时候你会问了，binlog 和 redo log 都是记录的修改之后的值，这两者有什么区别呢？记录了 redo log 可以不可以不记 binlog 呢？

首先看两者的区别：

binlog 是逻辑日志，记录的是对哪一个表的哪一行做了什么修改；redo log 是物理日志，记录的是对哪个数据页中的哪个记录做了什么修改，如果你还不了解数据页，你可以理解成对磁盘上的哪个数据做了修改。
binlog 是追加写；redo log 是循环写。
binlog 是 Server 层的日志；redo log 是 InnoDB 的日志。
但说实话，我觉得这些区别并不是 redo log 不能取代 binlog 的原因，完全可以调整 redo log 让他兼容现在 redo log 和 binlog 的能力。

我认为不用 redo log 取代 binlog 最大的原因是“没必要”。

为什么这么说呢？

第一点，binlog 的生态已经建立起来。MySQL 系统高可用依赖的就是 binlog 复制，还有很多公司的数据分析系统，也是依赖的 binlog。像阿里巴巴的开源框架 Canal，也是基于 binlog 开发的。

第二点，binlog 并不是 MySQL 的瓶颈，花时间在没有瓶颈的地方没必要。

就像我们常用的 Maven，在构建速度上已经被 Gradle 完爆了，但是我们新建项目的时候还是用着 Maven，为什么呢？

也是一样的道理，Maven 用的习惯了，构建慢但还没慢到影响项目开发的程度。

总结
需要提前交代清楚的是，因为 binlog 属于 MySQL 的 Server 层，而 redo log 和 undo log 是存储引擎 InnoDB 的日志，所以全文是在 MySQL 使用了 InnoDB 存储引擎的基础上展开的。
![](15.jpg)

事实上，这三种日志还有很多细节我没有提到，我花了 6000 字 3000 帧动画想要告诉你的只有三个词：恢复、回滚、归档。
而这每个词都对应着一种日志：

redo log——恢复
undo log——回滚
binlog——归档
这三种日志非常重要，是学习 MySQL 体系的基础，后面关于事务和 MVCC 的文章都会再次提到这些日志。
